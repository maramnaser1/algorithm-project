import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import javax.imageio.ImageIO;
import java.util.Scanner;

public class ImageReducer {

    public static void main(String[] args) {
        try {
            Scanner input = new Scanner(System.in);

            System.out.print("Insert the path of your image (example: C:\\\\Users\\\\Lina\\\\Downloads\\\\photo.jpg): ");
            String sourcePath = input.nextLine();

            System.out.print("How many seams would you like to delete? ");
            int seamCount = input.nextInt();
            input.close();

            // Load the selected image
            File sourceFile = new File(sourcePath);
            BufferedImage loadedImage = ImageIO.read(sourceFile);

            System.out.println("→ Original dimensions: width = " + loadedImage.getWidth() + ", height = " + loadedImage.getHeight());

            // Run brute-force seam carving step by step
            for (int s = 0; s < seamCount; s++) {
                double[][] pixelEnergy = generateEnergyMap(loadedImage);
                int[] bestPath = locateMinimalSeam(pixelEnergy);
                loadedImage = cutSeam(loadedImage, bestPath);
            }

            // Display final image dimensions
            System.out.println("→ Updated dimensions: width = " + loadedImage.getWidth() + ", height = " + loadedImage.getHeight());

            // Save final result to desktop
            String destination = System.getProperty("user.home") + "/Desktop/result_BF.jpg";
            ImageIO.write(loadedImage, "jpg", new File(destination));

            System.out.println("✅ Brute Force seam carving successfully done!");
            System.out.println("✔ Result saved at: " + destination);

        } catch (IOException ex) {
            System.out.println("⚠️ There was an issue reading or saving the image file.");
            ex.printStackTrace();
        }
    }

    // ------------------------- ENERGY MAP -------------------------
    // Builds an energy map for each pixel to represent its importance in the image
    public static double[][] generateEnergyMap(BufferedImage img) {
        int width = img.getWidth();
        int height = img.getHeight();
        double[][] map = new double[height][width];

        for (int row = 0; row < height; row++) {
            for (int col = 0; col < width; col++) {
                map[row][col] = calculateEnergyValue(img, col, row);
            }
        }
        return map;
    }

    // ------------------------- ENERGY CALCULATION -------------------------
    // Determines pixel energy using a simplified Sobel-like gradient
    private static double calculateEnergyValue(BufferedImage img, int x, int y) {
        int[][] colorMatrix = new int[3][3];
        for (int offsetY = -1; offsetY <= 1; offsetY++) {
            for (int offsetX = -1; offsetX <= 1; offsetX++) {
                int posX = x + offsetX;
                int posY = y + offsetY;

                if (posX < 0 || posY < 0 || posX >= img.getWidth() || posY >= img.getHeight()) {
                    colorMatrix[offsetY + 1][offsetX + 1] = 0;
                } else {
                    Color px = new Color(img.getRGB(posX, posY));
                    colorMatrix[offsetY + 1][offsetX + 1] = px.getRed() + px.getGreen() + px.getBlue();
                }
            }
        }

        int gradientX = colorMatrix[0][0] + 2 * colorMatrix[1][0] + colorMatrix[2][0]
                      - colorMatrix[0][2] - 2 * colorMatrix[1][2] - colorMatrix[2][2];
        int gradientY = colorMatrix[0][0] + 2 * colorMatrix[0][1] + colorMatrix[0][2]
                      - colorMatrix[2][0] - 2 * colorMatrix[2][1] - colorMatrix[2][2];

        return Math.sqrt(gradientX * gradientX + gradientY * gradientY);
    }

    // ------------------------- SEAM SELECTION -------------------------
    // Finds the seam with the smallest cumulative energy (brute-force approach)
    public static int[] locateMinimalSeam(double[][] energyMap) {
        int h = energyMap.length;
        int w = energyMap[0].length;
        int[] lowestPath = new int[h];
        double smallestEnergy = Double.MAX_VALUE;

        for (int start = 0; start < w; start++) {
            int[] currentSeam = new int[h];
            double currentEnergy = exploreSeam(energyMap, start, 0, currentSeam);

            if (currentEnergy < smallestEnergy || (currentEnergy == smallestEnergy && start < lowestPath[0])) {
                smallestEnergy = currentEnergy;
                System.arraycopy(currentSeam, 0, lowestPath, 0, h);
            }
        }
        return lowestPath;
    }

    // Recursive exploration of all possible seam paths
    private static double exploreSeam(double[][] energyMap, int x, int y, int[] route) {
        int h = energyMap.length;
        int w = energyMap[0].length;
        route[y] = x;

        if (y == h - 1) {
            return energyMap[y][x];
        }

        double minCost = Double.MAX_VALUE;
        for (int shift = -1; shift <= 1; shift++) {
            int nextX = x + shift;
            if (nextX >= 0 && nextX < w) {
                int[] tempRoute = new int[h];
                System.arraycopy(route, 0, tempRoute, 0, h);
                double nextCost = exploreSeam(energyMap, nextX, y + 1, tempRoute);
                if (nextCost < minCost) {
                    minCost = nextCost;
                    System.arraycopy(tempRoute, 0, route, 0, h);
                }
            }
        }
        return energyMap[y][x] + minCost;
    }

    // ------------------------- SEAM REMOVAL -------------------------
    // Removes the specified seam from the given image
    public static BufferedImage cutSeam(BufferedImage img, int[] seamPath) {
        int width = img.getWidth();
        int height = img.getHeight();
        BufferedImage output = new BufferedImage(width - 1, height, BufferedImage.TYPE_INT_RGB);

        for (int y = 0; y < height; y++) {
            int newX = 0;
            for (int x = 0; x < width; x++) {
                if (x != seamPath[y]) {
                    output.setRGB(newX, y, img.getRGB(x, y));
                    newX++;
                }
            }
        }
        return output;
    }
}
